# redis
    链式解决键值冲突问题。
    rehash 时候，写操作在hash[1]中。读优先hash[0]。没有再读hash[1]。等rehash完成后，hash[1] hash[0] 在互换。

## 底层数据结构
1、orderset 有序集合  数量少用ziplist（1、元素数量小于128，2、单个元素长度小于64字节）, 数量多用skiplist
    
    ziplist 对象由分值由小到大一次排列。
    skiplist 由：hashmap + jumplist 两个数据结构来实现。
    hashmap 字典来保证O（1）来判断元素是否在集合内
    jumplist 跳表来确保快速查找指定顺序元素。顺序遍历元素。

2、消息订阅
    
    固定频道：数据结构是一个字典(pubsub_channels)。频道名为key,订阅者是一个list.
    模式订阅：数据结构是一个list(*pubsub_patterns).每个list里的元素有两项，一个是模式规则。另一个是客户端列表。

## 内存管理
    引用计数来减少内存开销。对数值型数据进行对象共享。注意只对数值型的。字符型的不管。CPU开销不划算。

## 日志
1、慢查询日志(slow log)
    
    slowlog get  列出所有慢命令
     1)  1324097834  命令id
     2）14    命令执行时间
     3）’config’    具体命令
           “get”
           “* “
    slowlog  get 1324097834   只找某个慢查询
    slowlog  RESET  清除
    slowlog len 当前慢查询数量

查看配置
    config get slowlog-log-slower-than  查询执行多少算慢查询。
    config get slowlog-max-len 最多纪录多少条慢查询日志。

## 优化
    关闭持久化功能后，在不设定最大内存使用量的前提下，会出现内存占用过多的情况（脏页多）。
    原因：
    1、有一部分本应该刷新到硬盘的页数据，由于关闭了持久化。所以停留在内存中。
    2、由于没有对内存使用做上限，再加上过期是惰性淘汰。所以导致过期数据没有及时的清除。
    找到原因后，解决办法就是 对redis内存使用数量做一下限制。

## 数据持久化策略
    RDB 整体持久化redis 内存中的数据。 
    AOF 增量修改。只记录操作命令。相当于MySQL的日志文件，不同之处redis会进行操作合并（aof文件重写。生成新的aof文件,通过遍历当前数据实现）。以减少恢复操作。

### RDB策略
    RDB 有两种方式，
    一种是save。备份工作在主进程中完成。备份期间就提供不了外部访问。
    另一种bgsave。备份工作在主进程之外fork 出子进程。子进程把主进程中的数据拷贝一份。进行写文件操作。主进程这时候是可以对外提供服务器的。
    执行时机：
    1、redis服务器初始化过程中，设定了定时事件，每隔一段时间就会触发持久化操作。进入定时事件处理程序中，就会fork产生子进程执行持久化操作。
    2、redis 服务器预设了save指令，客户端可以要求服务器进程终端服务，执行持久化操作。

### AOF策略
    AOF策略（命令追加到缓冲区，缓冲区刷新到aof内存文件， aof文件刷新到磁盘 ）
    fork子进程，执行AOF持久化操作。与RDB不同的事，AOF过程中，主进程依旧提供服务。新生成的日志文件暂时存储在缓冲区中。本次持久化操作结束后追加到AOF文件中。

    缓冲区内的数据有三种刷新策略。appendfsync 值可选项
    1、always 每执行一次就刷新。效率低
    2、everysec 每个循环事件缓冲区里的数据写入到aof文件中。每隔1秒aof文件同步到磁盘中
    3、no每个循环事件都把缓冲区里的数据写入到aof文件中，至于aof何时写入磁盘，由操作系统控制。

    redis新开子进程进行AOF重写操作。子进程拥有当前库里数据的全集备份。redis 服务不停，重写期间的操作记录写入特殊的缓存区，待AOF重写完毕后，追加到新的AOF文件中。最后进行aof 文件的替换工作。

### 数据同步
    psync, sync 区别？
    psync 不用每次都生成一次快照。第一次会生成一次（用bgsave）快照。利用复制缓冲区来增量更新。
    数据结构上多了一个runid, offset；
    赋值缓冲区用于记录近期待同步的命令。只有offset在缓存区内，才说明从库更新是实时的。不在缓冲区内说明间隔太久。需要从新生成快照。进行全量更新。主库的有效从库列表内会删除这个从库。不让这个从库有机会成为主库。
    psync步骤是：
    1、从库发送同步命令到主库。第一次不带runid, offset。之后会带上runid, offset。
    2、主库收到后同步命令后，如果不没有runid, offset. 主库会把自己的id发送过去。另外执行bgsave.来生成快照。期间写操作命令会写入缓冲区内。快照生成完事后。发送快照文件给冲库。
    3、从库收到主库命令后。开始接受数据。
    4、从库如果中途失败，再次发送同步命令。带上runid, offset。主库在收到命令后，如果runid是自己, offset又在缓冲区内有效。否则同步命令无效。

### 事务失败情况
    RDB模式，只有事务成功执行了，才会进行RDB工作。如果事务失败了。这次修改的RDB 持久化时不会体现
    AOF模式下：
    1、如果事务语句未写入AOF文件，或则AOF未被SYNC调用保存到磁盘上，那么当事务结束后，redis可以更具最近一次成功保存到磁盘的AOF文件来还原数据库。只要AOF本身文件没有其他问题数据还是一致的。
    2、如果事务部分语句已经写入到磁盘。那么不完整的事务执行信息会遗留到AOF文件中。当重启redis时，程序会检查到AOF文件不完整，redis会退出，并报告错误，需要使用redis-check-aof工具将这部分命令移除，才能重启服务器。

## Redis安全问题
    请不要将Redis暴露在公开网络中, 因为让不受信任的客户接触到Redis是非常危险的
    1. 使用redis单独用户和组进行安全部署，并且在OS层面禁止此用户ssh登陆，这就从根本上防止了
        root用户启停redis带来的风险。
    2. 修改默认端口，降低网络简单扫描危害。
    3. 修改绑定地址，如果是本地访问要求绑定本地回环。
    4. 要求设置密码，并对配置文件访问权限进行控制，因为密码在其中是明文。
    5. HA环境下主从均要求设置密码。 另外，我们建议在网络防火墙层面进行保护，杜绝任何部署在外网直接可以访问的redis的出现。

## Redis事务
redis 是单进程单线程工作模式。即读写操作在同一个线程中完成。并发是通过io多路复用来实现的。

### 数据一致性问题
    Memcached提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题。 Redis没有提供cas 命令，并不能保证这点，不过Redis提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断。

### 事务基础命令
    MULTI     告诉redis服务器开始一个事务。
    EXEC      告诉redis服务器开始执行一个事务
    DISCARD   告诉redis服务器取消事务
    WATCH     监控某个键值对，她的作用是在事务执行之前如果监视的键值被修改，事务会被取消

    客户端在发送MULTI命令后，连续发送多条命令，之后在发送EXEC命令。即可不间断执行之前的多条命令。redis会在收到multi 命令后，exec命令之前的所有命令缓存起来，等收到exec后，再一次性的执行命令队列中的命令。在执行这一系列命令之前，如果有watch key。如果在操作过程中，发现键值有更改，那么事务失败。 key 值监控是人为的不是机械的。

    Watch 命令就是为了让redis 拥有 check and set(CAS)的特性。一个客户端在修改某个值之前，要检测她是否更改，如果没有更改操作才能成功。

    每一个客户端都有一个事务命令列表。
    watch机制。底层是一个dict。 键值为要监控的key, value是提出监控的客户端列表。
    当被监控的键值出现了值变动（set, lpush, rpush, sdd, zrem, del）
    对，相应的客户端列表里每一个客户端的 redis_dirty_cas值为真。Redis 在执行这些
    客户端事务时，检测到redis_dirty_cas值为真就取消事务。

## Redis数据淘汰机制
    1、volatile-lru   从已设置过期时间的数据集合中挑选最近最少使用的数据淘汰
    2、volatile-ttl   从设置过期时间的数据集合中挑选将要过期的数据淘汰
    3、volatile-random 从已经设置过期时间的数据集合中任意挑选数据淘汰
    4、allkeys-lru   从整体数据集合中挑选最近最少使用的数据淘汰
    5、allkeys-random  从整体数据集合中任意挑选数据淘汰
    6、no-enviction 不淘汰数据

    说明：
    每个数据都存有LRU数值。LRU数据没有另外表存储。
    LRU  
    淘汰机制是，从整体数据集合中，随机挑选几个key, 从这几个key中挑选最大的lru 进行淘汰。
    基于这个，被淘汰的数据也许不是最应该淘汰的。
    TTL 
    淘汰机制是，从过期时间表（redisDB.expires）中随机挑选几个键值对，取出TTL最大的键值进行淘汰。
    淘汰时机？
    redis 每执行一次客户端发送过来的命令，就会检测当前的内存使用量。如果超过阀值就执行淘汰操作。
    实际中，redis使用惰性删除和定期删除两种策略来删除过期键。

## 集群
    一致性hash
    客户端进行映射，更改映射比较麻烦。所有客户端都需要更改映射关系
    代理更改。就比较容易。只需要更改一个地方就是代理。 twemproxy 就是这么做的。 twemproxy （twitter开发的）兼容redis, memcached 协议。

    最新的redis已经支持集群。当redis服务器收到请求后，会看一下这个key是否需要映射到自己。如果映射到了就提供服务，如果没有映射到那么，找到对应的redis服务器，然后把请求redirect过去。但是这样做就浪费了一次请求。改进方法是，客户端定期去服务器获取映射关系。key 映射在客户端做。

    新节点如何加入到集群中。
    1、需要人工执行meet命令。操作。集群内的机器，向新加机器发送ping命令。新机器记录其他机器信息。建立映射表。
    2、启动新机器时，如果配置了集群信息。那新节点会把集群里的机器信息添加到映射表中。适时进行点对点联系。建立连接。

## 哨兵
    1、哨兵是一个redis服务器。启动它需要更改配置文件。
       redis-server /path/to/sentinel.conf —sentinel
    2、哨兵服务器不执行任何redis 命令。

### 哨兵机制工作流程
    redis 有两种连接类型。
    一种是普通连接，处理非订阅命令。 
    另一种是订阅发布专用连接。只处理订阅发布

    1、哨兵服务器向被监控redis 服务器发送hello订阅命令。 间隔10秒
    数据信息有（哨兵iP地址，端口，runid,当前配置版本，被监控redis 的iP， 端口，当前配置版本），被监控redis服务器再收到这个hello订阅命令后，会把这个订阅命令的信息发布出去，这样其他监控这台redis服务器的哨兵就知道其他哨兵的信息了。

    2、哨兵服务器向被监控redis服务器发送info
    命令 间隔2秒，redis服务器在收到info命令后返回当前redis服务信息。包括 版本，客户端连接情况，内存占用情况，持久化情况，其他状态，主从复制信息，所有丛机信息，CPU使用情况，存储的键值对数量。等等。哨兵通过info命令获取到丛机信息后，就可以和从机建立连接。

    3、哨兵自己通过心跳包来检查机器是否还在线（主观检测）间隔1秒。哨兵通过其他哨兵通知某台机器下线（客观检测）。

    4、故障恢复
    a、主哨兵选举   wait_start
    b、主机选举  select_slave
    c、哨兵向候选主机发送 slaveof_noone 命令。候选主机由从机转变主机
    d、哨兵向其他从机更新配置命令slaveof promote_slave。reconf_slaves 
    e、哨兵服务器直接同步信息。update_config
    f、同步完成。wait_promotion

### 常用命令
删除所有key:
    redis-cli -a pass(密码) keys "WX_ACT_USER_KEY_*" | xargs redis-cli -a pass(密码) del
查看所有key
    keys *
