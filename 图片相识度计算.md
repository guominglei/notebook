# 图片相识度计算
    关键点 
    1、一个合理的算法。标识唯一图片
    2、海量数据如何筛选出相识图片
        pg + smlar 插件 
            把64位特征值 16位一组。分成16组。建立索引。找相识度高的。肯定只有部分bit位不同
            由于建立了索引所以进行位运算的少了。
            pg 配置参数
            # set smlar.type = overlap;  
            # set smlar.threshold = 3;    4组索引。有三组相同就认为相同。剩下不同的再进行位运算。
            把64位特征值 16位一组。分成16组。建立索引。找相识度高的。肯定只有部分bit位不同

            不同的地方。假如分组内每一组都有一个bit位不同。虽然整体上只有4bit位不同。但是第一步索引部分就判错了。


    扩展：
        视频呢？ 
            1、抽关键帧， 每一帧做处理出一个签名。 
            2、对俩视频的，逐个比较关键帧的差异情况
        语音呢？
            pass

## hash算法
### aHash算法
    平均值hash。速度快但是不准确

    1、计算两张图片的dHash值
        1、图片缩放到 8 * 8 大小
        2、图片灰度化 颜色值 由3维降低成1维
        3、计算 8 * 8 的均值。并以均值为基础 对 8 * 8 做比较。
           大于均值的记为1，小于均值的记为0
        4、转换成hash。每8bit组成1个16进制的值。将这些16进制的数据连接起来就是一个字符串形成最后的hash值

    2、通过ahash计算两张图片的汉明距离，通过汉明距离的大小，判断两张图片的相识度
        将2个ahash转换成二进制 并且两者进行异或处理。 最后计算不同位的个数。

        如果小于5 这代表俩图片相同。 
        如果小于10 代表俩图片相识。
        这个值需要根据实际情况条

### dHash算法原理  差异值hash

    差异值hash。精度较高。速度也快。 
    缺点不能识别图片的变形。
    长用于利用缩略图找原图。

    1、计算两张图片的dHash值
        1、图片缩放到 9 * 8 或者 32 *33
        2、图片灰度化 由3维降低成1维
        3、计算差异化
            每一行，前后两个元素比较。前边大于后边强度高 记为1， 强度低记为0.
        4、转换成hash。每8bit组成1个16进制的值。将这些16进制的数据连接起来就是一个字符串形成最后的hash值

    2、通过dhash计算两张图片的汉明距离，通过汉明距离的大小，判断两张图片的相识度
        将2个dhash转换成二进制 并且两者进行异或处理。 最后计算不同位的个数。

        如果小于5 这代表俩图片相同。 
        如果小于10 代表俩图片相识。
        这个值需要根据实际情况条

### pHash算法原理 感知hash

    可以处理图片变形。

    1、计算phash
        1、缩放图片大小为32 * 32
        2、图片转为灰度模式 由3维降低成1维
        3、对图片进行二维余弦变换。
            高亮的元素位于左上角 8 * 8 的区域里。求出这个区域的均值。
        4、对高亮区域 8 * 8 的像素左均值hash运算。
        5、转换成hash。
    2、计算汉明距离
        将2个dhash转换成二进制 并且两者进行异或处理。 最后计算不同位的个数。
        如果小于5 这代表俩图片相同。 
        如果小于10 代表俩图片相识。
        这个值需要根据实际情况条

## MH Manhattan hashing 
    曼哈顿距离 hash

## 提取颜色特征

### 颜色直方图
    排除像素之间的微小差别比较图片间的接近度。
    根据不同的颜色空间和坐标系，有不同的方法。但原理基本相同。以通用RGB颜色体系为例

    1、缩小尺寸
        8 * 8  或者 32 * 32

    2、降低颜色值位深
       RGB每个颜色有256种值。降低到8种。 平均分配。 new,_ = mod(255, 32)  
    
    3、计算像素值
        分别给b,g, r 颜色值一个权重， 权重值为 8*8, 8, 1 。计算出每个像素的值
        value = b * (8 * 8） + g * 8 + r

    4、更新直方图值
        hist[value] = hist.get(value, 0) + 1

    5、 计算相识度
        用余弦相识度算法。计算出相同颜色出现次数的相识度。结果越接近1，代表相识度越高

## SIFT算法
    尺度不变特征转换。 用不同尺度（标志差）的高斯函数对图像进行平滑。然后比较平滑后图像的差别。差别大的像素就是图像的特征明显点。

    1、构建尺度空间，检测极值点。获得尺度不变性
    2、特征点过滤并精确定位，剔除不稳定的特征点。
    3、提取特征点的特征描述符。为特征值分配方向值。
    4、生成特征描述值。
    5、计算变换参数。
    
